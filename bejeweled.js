//Bejewled game. 
//The web-based game interface  displaying grid based diamond icons that can be increased in number based number of rows and column user has inputed at the start, game also display number of score and turn which subjected to change as user keep playing the game

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// Game Global variables
let turn = 5;// Initial number of turns
let score = 0;// Initial score
let gameOver = false;// Flag to indicate if the game is over
let intervalID;// Identifier for the timer interval

// Function to generate a random color path
function randomIndexColor() {
  let colors = ["pictures/rose.png", "pictures/gray.png", "pictures/yellow.png", "pictures/green.png", "pictures/pink.png", "pictures/teal.png"];
  return colors[Math.floor(Math.random() * colors.length)];
}
// Function to create a game cell with a random color
function createCell() {
  let cell = document.createElement("td");
  let img = document.createElement("img");

  // Set the src attribute to a random path generated by randomIndexColor()
  img.setAttribute("src", randomIndexColor());

  // Add the game-cell class
  cell.classList.add('game-cell');
  // Append the image to the cell
  cell.appendChild(img);
console.log(cell)
  return cell;
}
// Function to create a row with a specified number of columns
function createRow(numCols) {
  let tr = document.createElement("tr");
  for (let col = 0; col < numCols; col++) {
    let cell = createCell();
    tr.appendChild(cell);
  }
  return tr;
}
// Function to create a table with a specified number of rows and columns
function createTable(numRows, numCols) {
  let table = document.createElement("table");

  for (let row = 0; row < numRows; row++) {
    let tr = createRow(numCols);
    table.appendChild(tr);
  }

  return table;
}
// Function to display or injecting the game grid in the result div
function displayTable(gameGrid) {
  let resultDiv = document.getElementById('result');
  resultDiv.innerHTML = "";
  resultDiv.appendChild(gameGrid);
  console.log(resultDiv)
}
// Function to initialize the game
function initializeGame() {
    if (gameOver) {
        return;
    }

    let numRows = parseInt(document.getElementById('rowsInput').value);
    let numCols = parseInt(document.getElementById('columnsInput').value);

    if (isNaN(numRows) || isNaN(numCols) || numRows <= 0 || numCols <= 0) {
        alert("Please enter valid values for rows and columns.");
        return;
    }

    let gameGrid = createTable(numRows, numCols);
    displayTable(gameGrid);

    let cells = document.getElementsByClassName('game-cell');
    console.log(cells);

    // Loop through each cell using a traditional for loop
    for (let i = 0; i < cells.length; i++) {
        // Add a click event listener to the current cell
        cells[i].addEventListener('click', function (event) {
            // Traverse up the DOM tree to find the parent 'td' element
            let cell = event.target;
            while (cell.tagName.toLowerCase() !== 'td') {
                cell = cell.parentNode;
            }

            // When a cell is clicked, call the handleCellClick function with the game grid and the clicked cell as parameters
            handleCellClick(gameGrid, cell);
        });
    }
}

//function to deal with clicked cell inside table
function handleCellClick(gameGrid, cell) {
  if (gameOver) {
    return;
  }
console.log(gameGrid)
  let userRow = cell.parentNode.rowIndex;
  let userColumn = cell.cellIndex;

  let color = gameGrid.rows[userRow].cells[userColumn].querySelector('img').getAttribute('src');

  // Remove existing selected and marked classes
  clearCellClasses();

  // Highlight the selected cell
  cell.classList.add('selected-cell');

  // Highlight adjacent cells with the same color
  let cellsToBeHighlighted = cellsToHighlight(gameGrid, userRow, userColumn, color);
  for (let i = 0; i < cellsToBeHighlighted.length; i++) {
    let coord = cellsToBeHighlighted[i];
    let highlightedCell = gameGrid.rows[coord[0]].cells[coord[1]];
    highlightedCell.classList.add('marked-cell');
  }

  let cellsToBeRemoved = cellsToClear(gameGrid, userRow, userColumn, color);

  if (cellsToBeRemoved.length > 3) {
    turn += 0;
  } else {
    turn -= 1;
  }

  score += cellsToBeRemoved.length;

  deleteAndReplace(gameGrid, cellsToBeRemoved);
  displayTable(gameGrid);

  updateScoreAndTurns();

  if (turn <= 0) {
    gameOver = true;
  }

  // Set a timer to remove the highlighting after 1000 milliseconds (1 second)
  intervalID = setTimeout(function () {
    clearCellClasses();
  }, 500);
}
//This function is to remove specific CSS classes ('selected-cell' and 'marked-cell') from all elements with the class 'game-cell'.
function clearCellClasses() {
  let cells = document.querySelectorAll('.game-cell');
  for (let i = 0; i < cells.length; i++) {
    let cell = cells[i];
    cell.classList.remove('selected-cell', 'marked-cell');
  }
}
//This function is to apply visual highlighting to certain cells based on the clicked cell and its color.
function cellsToHighlight(gameGrid, userRow, userColumn, color) {
  return cellsToClear(gameGrid, userRow, userColumn, color);
}
// function to find adjacents cell depending on user cliced cell
function cellsToClear(gameGrid, userRow, userColumn, color) {
    let newCellsCoordinates = [];
    //top adjacent cell
    if (userRow - 1 >= 0 && gameGrid.rows[userRow - 1].cells[userColumn].querySelector('img').getAttribute('src') === color) {
      newCellsCoordinates.push([userRow - 1, userColumn]);
    }
  //bottom adjacent cell
    if (userRow + 1 < gameGrid.rows.length && gameGrid.rows[userRow + 1].cells[userColumn].querySelector('img').getAttribute('src') === color) {
      newCellsCoordinates.push([userRow + 1, userColumn]);
    }
  //left adjacent cell
    if (userColumn - 1 >= 0 && gameGrid.rows[userRow].cells[userColumn - 1].querySelector('img').getAttribute('src') === color) {
      newCellsCoordinates.push([userRow, userColumn - 1]);
    }
  //right adjacent cell
    if (userColumn + 1 < gameGrid.rows[0].cells.length && gameGrid.rows[userRow].cells[userColumn + 1].querySelector('img').getAttribute('src') === color) {
      newCellsCoordinates.push([userRow, userColumn + 1]);
    }
  
    newCellsCoordinates.push([userRow, userColumn]);
    return newCellsCoordinates;
  }
  // This function is for find highlighted cells and replace them by top adjacent cell
function deleteAndReplace(gameGrid, positions) {
  for (let i = 0; i < positions.length; i++) {
    let row = positions[i][0];
    let col = positions[i][1];

    if (row == 0) {
      gameGrid.rows[row].cells[col].querySelector('img').setAttribute('src', randomIndexColor());
    } else {
      while (row > 0) {
        gameGrid.rows[row].cells[col].querySelector('img').setAttribute('src', gameGrid.rows[row - 1].cells[col].querySelector('img').getAttribute('src'));
        row--;
      }
      gameGrid.rows[row].cells[col].querySelector('img').setAttribute('src', randomIndexColor());
    }
  }
}
// Function designed to update score and turns as user keep playing the game
function updateScoreAndTurns() {
  let scoreButton = document.getElementById('scoreButton');
  let turnsButton = document.getElementById('turnsButton');
  scoreButton.value = "Score: " + score;
  turnsButton.value = "Turns: " + turn;
}

// Initialize the game
initializeGame();
